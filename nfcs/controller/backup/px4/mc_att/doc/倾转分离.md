[toc]

# PX4倾转分离

首先，PX4位置控制器的输出会转换成四元数的期望传递给姿态控制器。姿态控制器在得到期望四元数之后并不是马上进行角速率期望的计算，而是先进行倾转分离的操作。

那什么是倾转分离？倾转其实是倾斜和旋转的意思，英文里一般用tilt和torsion表示，倾斜对应我们飞行器也就是机体轴系Z轴方向的变化，旋转对应我们飞行器是指绕机体轴系Z轴的旋转运动，倾转分离就是将倾斜和旋转运动从总的姿态期望中剥离出来。

为什么要进行倾转分离？有以下三个原因：

首先，在飞行器实际飞行中，电机的能力是有限的，除了用来平衡飞行器本身的重力之外，留给姿态机动的空间就不是特别充足。而倾斜和旋转两种运动的原理是不同的，倾斜运动是由不同电机差速运动产生的升力差形成的力矩驱使的，而旋转运动是由不同电机差速运动产生的反扭矩驱使的，前者在数值上往往要比后者大很多。

其次，由于绕Z轴的转动惯量也比绕X、Y轴的转动惯量要大得多，所以要改变旋转运动比改变倾斜运动的难度要大很多，所需要占用电机的控制也要大得多。在这种情况下，我们往往需要对旋转运动进行一定的限制，避免在机动时出现电机饱和的情况。

最后，多旋翼飞行器一般是沿X轴和Y轴对称，所以航向朝向哪边真没那么重要，所以在姿态控制中优先保证倾斜也是合情合理的。为此，在PX4中还特别设定了在航线飞行时保持航向不变的飞行模式。

## 各四元数表示的坐标系旋转关系

N：惯性系；B：机体系；M：中间状态坐标系；T：最终体轴系；

- $q: B系向N系旋转$；
- $qd: T系向N系旋转$；
- $qd\_red: M系向N系旋转$；
- $qd\_mix: T系向M系旋转$；
- $qe\_tilt: B系向M系旋转，转轴在N系$；
- $qd\_tilt^{'}: T系向M系旋转，转轴在B系或M系$；

vehicle_attitude.msg中的q的旋转方向是从B系到N系；

DCM与q的旋转方向相反，DCM表示的是N系到B系；

## 旋转方向

在函数`AttitudeControl::update(const Quatf &q)`中：

e_z：从I系下观察，B系下当前姿态的Z轴旋转量；

e_z_d：从I系下观察，B系下期望姿态的Z轴旋转量；

qd_red：从I系下观察，当前姿态与期望姿态z轴对齐的旋转，但x轴与y轴并未对齐；此时无人机的roll和pitch是对齐了的，但是yaw没有对齐，这个也是倾转分离中，优先保持水平方向的角度对齐高于航向角的对齐；

`qd_red *= q;`等于`qd_red = qd_red * q`，从I系下观察，当前姿态到z轴对齐的旋转；其实就是只有航向没对齐的中间姿态；

```c++
// mix full and reduced desired attitude
Quatf q_mix = qd_red.inversed() * qd;
q_mix.canonicalize();
```

其中：从B系到D系的旋转可以表示为：$q_{M}^{D} = (q_{M}^{I})^{-1} \times q_{I}^{D}$，再将`q_mix`中的负号转成正数，正数不变。

```c++
// catch numerical problems with the domain of acosf and asinf
q_mix(0) = math::constrain(q_mix(0), -1.f, 1.f);
q_mix(3) = math::constrain(q_mix(3), -1.f, 1.f);
```

这里，对第一个元素与第三个元素限幅的原因如下：

一个坐标系绕轴$r = [a \quad b \quad c], \quad (a^2 + b^2 + c^2) = 1$旋转$\alpha$角度的过程可以用四元数表示为：
$$
q(\alpha,r) = [\cos(\frac{\alpha}{2}), a\sin(\frac{\alpha}{2}), b\sin(\frac{\alpha}{2}), c\sin(\frac{\alpha}{2})]^{T}
$$
所以，绕z轴旋转的话，需要对其限制在$-1 \sim +1$之间；

## 给与yaw一定的权重

该权重来源于参数`MC_YAW_WEIGHT`，默认0.4

```c++
qd = qd_red * Quatf(cosf(_yaw_w * acosf(q_mix(0))), 0, 0, sinf(_yaw_w * asinf(q_mix(3))));
```

其中：asinf(q_mix(3))表示原来需要转的航向角度；



